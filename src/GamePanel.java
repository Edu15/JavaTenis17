import java.awt.Color;import java.awt.Dimension;import java.awt.Font;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.util.ArrayList;import java.util.List;import javax.swing.JPanel;import java.util.Random;public class GamePanel extends JPanel implements Runnable{	private static final long serialVersionUID = 1L;		private Thread animator;		// for the animation		private volatile boolean running = false;			private volatile boolean gameOver = false;			private volatile boolean paused = false;			private volatile boolean win = false;		private Integer points;	int yGlobal = 10;	long period = 1000/60;	float ballSpeed;		private Graphics dbg;	private Image dbImage = null;		private static final int PWIDTH = 800;	private static final int PHEIGHT = 600;			Ball ball = new Ball(); 	Bar bar;		private volatile List<Box> boxesList = new ArrayList<Box>();	private volatile static Random rand;		private SoundEffect barHitSound, boxHitSound, winSound, loseSound, wallBounceSound;			public GamePanel(int difficulty) {				switch (difficulty) {		case 0: 			ballSpeed = 8;			bar = new Bar(200);			break;					case 1:			ballSpeed = 10;			bar = new Bar(150);			break;				case 2:			ballSpeed = 13;			bar = new Bar(100);			break;					default:			ballSpeed = 8;			bar = new Bar(200);		}						initialState();		setFocusable(true);		requestFocus();// JPanel now receives key events		readyForTermination( );				// listen for mouse presses		/*addMouseListener( new MouseAdapter( ) {			public void mousePressed(MouseEvent e)			{ testPress(e.getX( ), e.getY( )); }		});*/				boxHitSound = new SoundEffect("hit0.wav");		barHitSound = new SoundEffect("hit1.wav");		winSound = new SoundEffect("win0.wav");		loseSound = new SoundEffect("lose0.wav");		wallBounceSound = new SoundEffect("hit1.wav");	}			public void initialState() {		win = false;		gameOver = false;		points = 0;				setBackground(Color.white);		setPreferredSize(new Dimension(PWIDTH, PHEIGHT));		ball.position.x = PWIDTH/2;		ball.position.y = PHEIGHT-400;		bar.position.x = PWIDTH/2 ;		bar.position.y = PHEIGHT-35;		ball.velocity.y = 1;		boxesList.clear();		int frameUnit = 50;				int boxAreaWidth = (PWIDTH - 2*50)/frameUnit;		int boxAreaHeight = 3;			rand = new Random(System.currentTimeMillis());		boolean inSamePlace;		// Randomly set boxes in a frame		for (int i = 0; i < 25; i++) {			Box newBox = new Box(44);			do {				newBox.position.x =  (float)rand.nextInt(boxAreaWidth);				newBox.position.y = (float)rand.nextInt(boxAreaHeight);				inSamePlace = false;				for (Box b: boxesList) {					if (b.isInSamePlaceAs(newBox)) {						inSamePlace = true;						break;					}				}			} while (inSamePlace);						boxesList.add(newBox);		}				// Position boxes in the game area		for (Box b: boxesList) {			b.position.x = (b.position.x * frameUnit) + b.size/2 + frameUnit;			b.position.y = (b.position.y * frameUnit) + b.size/2 + frameUnit;		}					}				private void testPress(int x, int y)	// is (x,y) important to the game?	{		if (!gameOver) {			// do something			System.out.println("Click em x: "+x+" e y: "+y);		}	}		private void readyForTermination( )	{		addKeyListener( new KeyAdapter( ) {			// listen for esc, q, end, ctrl-c			public void keyPressed(KeyEvent e)			{ 				int keyCode = e.getKeyCode( );				if ((keyCode == KeyEvent.VK_ESCAPE) || (keyCode == KeyEvent.VK_Q) || (keyCode == KeyEvent.VK_END) || ((keyCode == KeyEvent.VK_C) && e.isControlDown( )) ) {					running = false;				}				else if (keyCode == KeyEvent.VK_LEFT) {					bar.velocity.x = bar.velocity.x - 30;				}				else if (keyCode == KeyEvent.VK_RIGHT) {					bar.velocity.x += 30;									}				else if (keyCode == KeyEvent.VK_SPACE) {					if (gameOver) {						initialState();						gameOver = false;					}					else {						paused = !paused;					}					//bar.position.x = bar.position.x > PWIDTH ? bar.position.x - 50 : bar.position.x;				}							}		});	} // end of readyForTermination( )			public void addNotify() {		super.addNotify();		startGame();	}		private void startGame() {		if (animator == null || !running) {			animator = new Thread(this);			animator.start();		}	}		public void stopGame() {		running = false;	}		@Override	public void run() {		long beforeTime, timeDiff, sleepTime;		beforeTime = System.currentTimeMillis( );				running = true;		while (running) {			if (!paused) {				gameUpdate(); // game state is updated				gameRender(); // render to a buffer				paintScreen(); // draw buffer to screen								timeDiff = System.currentTimeMillis( ) - beforeTime;				//System.out.println(timeDiff);								sleepTime = period - timeDiff; // time left in this loop								if (sleepTime <= 0) // update/render took longer than period					sleepTime = 5; // sleep a bit anyway								try {					Thread.sleep(sleepTime);				}				catch(InterruptedException ex) {					System.out.println("error");				}								beforeTime = System.currentTimeMillis( );			}		}		System.exit(0);	}		private void paintScreen( )	// actively render the buffer image to the screen	{		Graphics g;		try {			g = this.getGraphics( ); // get the panel's graphic context			if ((g != null) && (dbImage != null))				g.drawImage(dbImage, 0, 0, null);			Toolkit.getDefaultToolkit( ).sync( ); // sync the display on some systems			g.dispose( );		}		catch (Exception e)	{ 			System.out.println("Graphics context error: " + e); 		}	} // end of paintScreen( )			private void gameUpdate() {				if (gameOver) 			return;		ball.normalizeVelocity();		ball.position.x += ball.velocity.x * ballSpeed;		ball.position.y += ball.velocity.y * ballSpeed;				bar.velocity.x = Math.abs(bar.velocity.x) < 1 ? 0 : bar.velocity.x * 0.8f;		bar.position.x += bar.velocity.x;				if (ball.isCloseToBar(bar, 0)) {			barHitSound.play();			ball.velocity.y *= (-1);			ball.position.y -= 10;			ball.velocity.x += bar.velocity.x * 0.5;		}		if (ball.position.x < ball.radius || (ball.position.x + ball.radius) > PWIDTH){			wallBounceSound.play();			ball.velocity.x *= (-1);					}		else if (ball.position.y < ball.radius) {			wallBounceSound.play();			ball.velocity.y *= (-1);		}		else if (PHEIGHT < ball.position.y) {			gameOver = true;			loseSound.play();		}						if (bar.position.x < (bar.width/2) ) {			bar.velocity.x = 0;			bar.position.x = bar.width/2;		}		else if (bar.position.x + bar.width/2 > PWIDTH){			bar.velocity.x = 0;			bar.position.x = PWIDTH - bar.width/2;		}				boolean winner = true;		for (Box b: boxesList) {			if (!b.hidden) {				if (ball.isCloseToBox(b)) {					b.hidden = true;					boxHitSound.play();					ball.bounceOverBox(b);					points += 1;				}				winner = false;			}		}		if (winner) {			win = true;			winSound.play();			gameOver = true;		}	}		private void gameRender() 	// draw the current frame to an image buffer	{		if (dbImage == null) { // create the buffer			dbImage = createImage(PWIDTH, PHEIGHT);			if (dbImage == null) {				System.out.println("dbImage is null");				return;			}			else {				dbg = dbImage.getGraphics();			}		}				// clear the background		dbg.setColor(Color.white);		dbg.fillRect (0, 0, PWIDTH, PHEIGHT);						for (Box b: boxesList) {			if (!b.hidden)				b.draw(dbg);		}				dbg.setColor(Color.gray);		Font f = new Font("arial",0, 20);		dbg.setFont(f);		dbg.drawString("Pts: " + points.toString(), 10, 30);		// draw game elements		ball.draw(dbg);		bar.draw(dbg);						if (gameOver)			gameOverMessage(dbg);	}				private void gameOverMessage(Graphics g) { 		Font f = new Font("arial",0, 30);		g.setFont(f);		if (win) {			g.drawString("YOU WON", PWIDTH/2-80, PHEIGHT/2);		} 		else {			g.drawString("GAME OVER", PWIDTH/2-80, PHEIGHT/2);		}							} // end of gameOverMessage( )		public void paintComponent(Graphics g)	{		super.paintComponent(g);		if (dbImage != null)			g.drawImage(dbImage, 0, 0, null);	}}